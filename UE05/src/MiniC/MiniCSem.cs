// MiniCSem.cs                                              HDO, 2006-08-28
// -------------
// Semantic evaluator for table-driven top-down parsing.
// Generated by Coco-2 (PGT).
//=====================================|========================================

using System;
using System.Text;

using Lex = MiniCLex;
using Syn = MiniCSyn;

public class MiniCSem {


  public const String MODULENAME = "MiniCSem";

  public static void MiniCSemMethod(Utils.ModuleAction action, out String moduleName) {
  //-----------------------------------|----------------------------------------
    moduleName = MODULENAME;
    switch (action) {
      case Utils.ModuleAction.getModuleName:
        return;
      case Utils.ModuleAction.initModule:
        break;
      case Utils.ModuleAction.resetModule:
        break;
      case Utils.ModuleAction.cleanupModule:
        return;
    } // switch
  } // MiniCSemMethod


  // *** start of global SYN and SEM declarations from ATG ***
  

  // *** end of global SYN and SEM declarations from ATG ***

  

  private static void NT_MiniC() {
    for (;;) {
      switch (Syn.Interpret()) {
        case 0:
          return;
        case 1:
          NT_VarDecl();
          break;
        case 2:
          NT_StatSeq();
          break;
      } // switch
    } // for
  } // NT_MiniC

  private static void NT_VarDecl() {
    for (;;) {
      switch (Syn.Interpret()) {
        case 0:
          return;
        case 1:
          Lex.GETidentAttr(out string id1);
          break;
        case 2:
          Lex.GETidentAttr(out string id2);
          break;
      } // switch
    } // for
  } // NT_VarDecl

  private static void NT_StatSeq() {
    for (;;) {
      switch (Syn.Interpret()) {
        case 0:
          return;
        case 1:
          NT_Stat();
          break;
        case 2:
          NT_Stat();
          break;
      } // switch
    } // for
  } // NT_StatSeq

  private static void NT_Stat() {
    for (;;) {
      switch (Syn.Interpret()) {
        case 0:
          return;
        case 1:
          Lex.GETidentAttr(out string id1);
          break;
        case 2:
          NT_Expr();
          break;
        case 3:
          Lex.GETidentAttr(out string id2);
          break;
        case 4:
          NT_Expr();
          break;
      } // switch
    } // for
  } // NT_Stat

  private static void NT_Expr() {
    for (;;) {
      switch (Syn.Interpret()) {
        case 0:
          return;
        case 1:
          NT_Term();
          break;
        case 2:
          NT_Term();
          break;
        case 3:
          NT_Term();
          break;
      } // switch
    } // for
  } // NT_Expr

  private static void NT_Term() {
    for (;;) {
      switch (Syn.Interpret()) {
        case 0:
          return;
        case 1:
          NT_Fact();
          break;
        case 2:
          NT_Fact();
          break;
        case 3:
          NT_Fact();
          break;
      } // switch
    } // for
  } // NT_Term

  private static void NT_Fact() {
    int f = 0; string id = "";
    for (;;) {
      switch (Syn.Interpret()) {
        case 0:
          return;
        case 1:
          Lex.GETidentAttr(out id);
          break;
        case 2:
          Lex.GETnumberAttr(out f);
          break;
        case 3:
          NT_Expr();
          break;
      } // switch
    } // for
  } // NT_Fact


  public delegate void PragmaMethod();
  public static PragmaMethod[] pragmaMethods = {
      // none
    };


  public static void StartSem() {
  //-----------------------------------|----------------------------------------
    for (;;) {
      switch (Syn.Interpret()) {
        case 0:
          return;
        case 1:
          NT_MiniC();
          break;
      } // switch
    } // for
  } // StartSem

    
} // MiniCSem

// End of MiniCSem.cs
//=====================================|========================================
// MiniCppSem.cs                                              HDO, 2006-08-28
// -------------
// Semantic evaluator for table-driven top-down parsing.
// Generated by Coco-2 (PGT).
//=====================================|========================================

using System;
using System.Text;

using Lex = MiniCppLex;
using Syn = MiniCppSyn;

public class MiniCppSem {


  public const String MODULENAME = "MiniCppSem";

  public static void MiniCppSemMethod(Utils.ModuleAction action, out String moduleName) {
  //-----------------------------------|----------------------------------------
    moduleName = MODULENAME;
    switch (action) {
      case Utils.ModuleAction.getModuleName:
        return;
      case Utils.ModuleAction.initModule:
        break;
      case Utils.ModuleAction.resetModule:
        break;
      case Utils.ModuleAction.cleanupModule:
        return;
    } // switch
  } // MiniCppSemMethod


  // *** start of global SYN and SEM declarations from ATG ***
  
  private static int numStats = 0;
  private static System.Collections.Generic.HashSet<string> operators = new System.Collections.Generic.HashSet<string>();
  private static System.Collections.Generic.HashSet<string> operands = new System.Collections.Generic.HashSet<string>();
  private static int numOfOperands = 0;
  private static int numOfOperators = 0;
  private static int structuralComplexity = 1;
  public static void addOperator(string tmp) {
    operators.Add(tmp);
    numOfOperators++;
  }
  public static void addOperand(string tmp) {
    Console.WriteLine(tmp);
    operands.Add(tmp);
    numOfOperands++;
  }

  // *** end of global SYN and SEM declarations from ATG ***

  

  private static void NT_MiniCpp() {
    string idStr = "";
    for (;;) {
      switch (Syn.Interpret()) {
        case 0:
          return;
        case 1:
          NT_ConstDef();
          break;
        case 2:
          NT_Type();
          break;
        case 3:
          Lex.GETidentAttr(out idStr);
          break;
        case 4: // SEM
          addOperand("ident"+ idStr);
          break;
        case 5:
          NT_LL1Stuff();
          break;
        case 6: // SEM
          Console.WriteLine("Nr of Statements: " + numStats);
          Console.WriteLine("Structural Complexity: " + structuralComplexity);
          Console.WriteLine("Lines of code: " + MiniCppLex.curLine);
          Console.WriteLine("n1: " + operators.Count + " N1: " + numOfOperators);
          Console.WriteLine("n2: " + operands.Count + " N2: " + numOfOperands);
          int n = operators.Count + operands.Count;
          int N = numOfOperators + numOfOperands;
          double V = N * Math.Log(n, 2);
          int D = (operators.Count * numOfOperands) / (2 * operands.Count);
          Console.WriteLine("Vocabulary n: " + n);
          Console.WriteLine("Length N: " + N);
          Console.WriteLine("Volume V: " + V);
          Console.WriteLine("Difficulty D: " + D);
          Console.WriteLine("Effort E: " + (D*V));

          break;
      } // switch
    } // for
  } // NT_MiniCpp

  private static void NT_ConstDef() {
    string idStr="";
    for (;;) {
      switch (Syn.Interpret()) {
        case 0:
          return;
        case 1:
          NT_Type();
          break;
        case 2:
          Lex.GETidentAttr(out idStr);
          break;
        case 3: // SEM
          addOperand("ident"+ idStr);
          break;
        case 4:
          NT_Init();
          break;
        case 5:
          Lex.GETidentAttr(out idStr);
          break;
        case 6: // SEM
          addOperand("ident"+ idStr);
          break;
        case 7:
          NT_Init();
          break;
      } // switch
    } // for
  } // NT_ConstDef

  private static void NT_Init() {
    string sign = ""; int n = 0;
    for (;;) {
      switch (Syn.Interpret()) {
        case 0:
          return;
        case 1: // SEM
          addOperator("=");
          break;
        case 2: // SEM
          addOperand("false");
          break;
        case 3: // SEM
          addOperand("true");
          break;
        case 4: // SEM
          addOperand("nullptr");
          break;
        case 5: // SEM
          sign = "-";
          break;
        case 6:
          Lex.GETnumberAttr(out n);
          break;
        case 7: // SEM
          addOperand("num"+sign+n);
          break;
      } // switch
    } // for
  } // NT_Init

  private static void NT_VarDef() {
    string idStr="";
    for (;;) {
      switch (Syn.Interpret()) {
        case 0:
          return;
        case 1:
          NT_Init();
          break;
        case 2:
          Lex.GETidentAttr(out idStr);
          break;
        case 3: // SEM
          addOperand("ident"+ idStr);
          break;
        case 4:
          NT_Init();
          break;
      } // switch
    } // for
  } // NT_VarDef

  private static void NT_LL1Stuff() {
    for (;;) {
      switch (Syn.Interpret()) {
        case 0:
          return;
        case 1:
          NT_VarDef();
          break;
        case 2:
          NT_FuncHead();
          break;
        case 3:
          NT_FuncStuff();
          break;
      } // switch
    } // for
  } // NT_LL1Stuff

  private static void NT_FuncStuff() {
    for (;;) {
      switch (Syn.Interpret()) {
        case 0:
          return;
        case 1:
          NT_FuncDecl();
          break;
        case 2:
          NT_FuncDef();
          break;
      } // switch
    } // for
  } // NT_FuncStuff

  private static void NT_FuncDecl() {
    for (;;) {
      switch (Syn.Interpret()) {
        case 0:
          return;
      } // switch
    } // for
  } // NT_FuncDecl

  private static void NT_FuncDef() {
    for (;;) {
      switch (Syn.Interpret()) {
        case 0:
          return;
        case 1:
          NT_Block();
          break;
      } // switch
    } // for
  } // NT_FuncDef

  private static void NT_FuncHead() {
    for (;;) {
      switch (Syn.Interpret()) {
        case 0:
          return;
        case 1:
          NT_FormParList();
          break;
      } // switch
    } // for
  } // NT_FuncHead

  private static void NT_FormParList() {
    string idStr="";
    for (;;) {
      switch (Syn.Interpret()) {
        case 0:
          return;
        case 1:
          NT_VoidRule();
          break;
        case 2:
          Lex.GETidentAttr(out idStr);
          break;
        case 3: // SEM
          addOperand("ident"+ idStr);
          break;
        case 4:
          NT_Type();
          break;
        case 5:
          Lex.GETidentAttr(out idStr);
          break;
        case 6: // SEM
          addOperand("ident"+ idStr);
          break;
      } // switch
    } // for
  } // NT_FormParList

  private static void NT_VoidRule() {
    string idStr="";
    for (;;) {
      switch (Syn.Interpret()) {
        case 0:
          return;
        case 1:
          Lex.GETidentAttr(out idStr);
          break;
        case 2: // SEM
          addOperand("ident"+ idStr);
          break;
        case 3:
          NT_Type();
          break;
        case 4:
          Lex.GETidentAttr(out idStr);
          break;
        case 5: // SEM
          addOperand("ident"+ idStr);
          break;
      } // switch
    } // for
  } // NT_VoidRule

  private static void NT_Type() {
    for (;;) {
      switch (Syn.Interpret()) {
        case 0:
          return;
      } // switch
    } // for
  } // NT_Type

  private static void NT_Block() {
    string idStr="";
    for (;;) {
      switch (Syn.Interpret()) {
        case 0:
          return;
        case 1:
          NT_ConstDef();
          break;
        case 2:
          NT_Type();
          break;
        case 3:
          Lex.GETidentAttr(out idStr);
          break;
        case 4: // SEM
          addOperand("ident"+ idStr);
          break;
        case 5:
          NT_VarDef();
          break;
        case 6:
          NT_Stat();
          break;
      } // switch
    } // for
  } // NT_Block

  private static void NT_Stat() {
    for (;;) {
      switch (Syn.Interpret()) {
        case 0:
          return;
        case 1:
          NT_EmptyStat();
          break;
        case 2:
          NT_BlockStat();
          break;
        case 3:
          NT_ExprStat();
          break;
        case 4:
          NT_IfStat();
          break;
        case 5: // SEM
          structuralComplexity++;
          break;
        case 6:
          NT_WhileStat();
          break;
        case 7: // SEM
          structuralComplexity++;
          break;
        case 8:
          NT_BreakStat();
          break;
        case 9:
          NT_InputStat();
          break;
        case 10:
          NT_OutputStat();
          break;
        case 11:
          NT_DeleteStat();
          break;
        case 12:
          NT_ReturnStat();
          break;
        case 13: // SEM
          numStats++;
          break;
      } // switch
    } // for
  } // NT_Stat

  private static void NT_EmptyStat() {
    for (;;) {
      switch (Syn.Interpret()) {
        case 0:
          return;
      } // switch
    } // for
  } // NT_EmptyStat

  private static void NT_BlockStat() {
    for (;;) {
      switch (Syn.Interpret()) {
        case 0:
          return;
        case 1:
          NT_Block();
          break;
      } // switch
    } // for
  } // NT_BlockStat

  private static void NT_ExprStat() {
    for (;;) {
      switch (Syn.Interpret()) {
        case 0:
          return;
        case 1:
          NT_Expr();
          break;
      } // switch
    } // for
  } // NT_ExprStat

  private static void NT_IfStat() {
    for (;;) {
      switch (Syn.Interpret()) {
        case 0:
          return;
        case 1: // SEM
          addOperator("if");
          break;
        case 2:
          NT_Expr();
          break;
        case 3:
          NT_Stat();
          break;
        case 4: // SEM
          addOperator("else");
          break;
        case 5:
          NT_Stat();
          break;
      } // switch
    } // for
  } // NT_IfStat

  private static void NT_WhileStat() {
    for (;;) {
      switch (Syn.Interpret()) {
        case 0:
          return;
        case 1: // SEM
          addOperator("while");
          break;
        case 2:
          NT_Expr();
          break;
        case 3:
          NT_Stat();
          break;
      } // switch
    } // for
  } // NT_WhileStat

  private static void NT_BreakStat() {
    for (;;) {
      switch (Syn.Interpret()) {
        case 0:
          return;
        case 1: // SEM
          addOperator("break");
          break;
      } // switch
    } // for
  } // NT_BreakStat

  private static void NT_InputStat() {
    string idStr="";
    for (;;) {
      switch (Syn.Interpret()) {
        case 0:
          return;
        case 1: // SEM
          addOperator("cin");
          break;
        case 2: // SEM
          addOperator("cinSy");
          break;
        case 3:
          Lex.GETidentAttr(out idStr);
          break;
        case 4: // SEM
          addOperand("ident"+ idStr);
          break;
      } // switch
    } // for
  } // NT_InputStat

  private static void NT_OutputStat() {
    string str="";
    for (;;) {
      switch (Syn.Interpret()) {
        case 0:
          return;
        case 1: // SEM
          addOperator("cout");
          break;
        case 2: // SEM
          addOperator("coutSy");
          break;
        case 3:
          NT_Expr();
          break;
        case 4:
          Lex.GETstringAttr(out str);
          break;
        case 5: // SEM
          addOperand("str"+str);
          break;
        case 6: // SEM
          addOperator("endl");
          break;
        case 7: // SEM
          addOperator("coutSy");
          break;
        case 8:
          NT_Expr();
          break;
        case 9:
          Lex.GETstringAttr(out str);
          break;
        case 10: // SEM
          addOperand("str"+str);
          break;
        case 11: // SEM
          addOperator("endl");
          break;
      } // switch
    } // for
  } // NT_OutputStat

  private static void NT_DeleteStat() {
    string idStr="";
    for (;;) {
      switch (Syn.Interpret()) {
        case 0:
          return;
        case 1: // SEM
          addOperator("delete");
          break;
        case 2:
          Lex.GETidentAttr(out idStr);
          break;
        case 3: // SEM
          addOperand("ident"+ idStr);
          break;
      } // switch
    } // for
  } // NT_DeleteStat

  private static void NT_ReturnStat() {
    for (;;) {
      switch (Syn.Interpret()) {
        case 0:
          return;
        case 1: // SEM
          addOperator("return");
          break;
        case 2:
          NT_Expr();
          break;
      } // switch
    } // for
  } // NT_ReturnStat

  private static void NT_Expr() {
    for (;;) {
      switch (Syn.Interpret()) {
        case 0:
          return;
        case 1:
          NT_OrExpr();
          break;
        case 2: // SEM
          operators.Add("="); numOfOperators++;
          break;
        case 3: // SEM
          operators.Add("+="); numOfOperators++;
          break;
        case 4: // SEM
          operators.Add("-="); numOfOperators++;
          break;
        case 5: // SEM
          operators.Add("*="); numOfOperators++;
          break;
        case 6: // SEM
          operators.Add("/="); numOfOperators++;
          break;
        case 7: // SEM
          operators.Add("%="); numOfOperators++;
          break;
        case 8:
          NT_OrExpr();
          break;
      } // switch
    } // for
  } // NT_Expr

  private static void NT_OrExpr() {
    for (;;) {
      switch (Syn.Interpret()) {
        case 0:
          return;
        case 1:
          NT_AndExpr();
          break;
        case 2: // SEM
          addOperator("||");
          break;
        case 3:
          NT_AndExpr();
          break;
      } // switch
    } // for
  } // NT_OrExpr

  private static void NT_AndExpr() {
    for (;;) {
      switch (Syn.Interpret()) {
        case 0:
          return;
        case 1:
          NT_RelExpr();
          break;
        case 2: // SEM
          addOperator("&&");
          break;
        case 3:
          NT_RelExpr();
          break;
      } // switch
    } // for
  } // NT_AndExpr

  private static void NT_RelExpr() {
    for (;;) {
      switch (Syn.Interpret()) {
        case 0:
          return;
        case 1:
          NT_SimpleExpr();
          break;
        case 2: // SEM
          addOperator("==");
          break;
        case 3: // SEM
          addOperator("!=");
          break;
        case 4: // SEM
          addOperator("smaller");
          break;
        case 5: // SEM
          addOperator("smallereq");
          break;
        case 6: // SEM
          addOperator("greater");
          break;
        case 7: // SEM
          addOperator("greaterEq");
          break;
        case 8:
          NT_SimpleExpr();
          break;
      } // switch
    } // for
  } // NT_RelExpr

  private static void NT_SimpleExpr() {
    string sign = ""; int n = 0; bool isNum = false;
    for (;;) {
      switch (Syn.Interpret()) {
        case 0:
          return;
        case 1: // SEM
          sign = "-";
          break;
        case 2:
          NT_Term(out isNum, out n);
          break;
        case 3: // SEM
          if(isNum) addOperand("num"+sign+n);
          break;
        case 4: // SEM
          addOperator("+");
          break;
        case 5: // SEM
          addOperator("-");
          break;
        case 6:
          NT_Term(out isNum, out n);
          break;
      } // switch
    } // for
  } // NT_SimpleExpr

  private static void NT_Term(out bool isNum, out int n) {
    isNum = false; n = 0;
    for (;;) {
      switch (Syn.Interpret()) {
        case 0:
          return;
        case 1:
          NT_NotFact(out isNum, out n);
          break;
        case 2: // SEM
          addOperator("*");
          break;
        case 3: // SEM
          addOperator("/");
          break;
        case 4: // SEM
          addOperator("%");
          break;
        case 5:
          NT_NotFact(out isNum, out n);
          break;
      } // switch
    } // for
  } // NT_Term

  private static void NT_NotFact(out bool isNum, out int n) {
    isNum = false; n = 0;
    for (;;) {
      switch (Syn.Interpret()) {
        case 0:
          return;
        case 1: // SEM
          addOperator("!");
          break;
        case 2:
          NT_Fact(out isNum, out n);
          break;
      } // switch
    } // for
  } // NT_NotFact

  private static void NT_Fact(out bool isNum, out int n) {
    string idStr=""; n = 0; isNum = false;
    for (;;) {
      switch (Syn.Interpret()) {
        case 0:
          return;
        case 1: // SEM
          addOperand("false");
          break;
        case 2: // SEM
          addOperand("true");
          break;
        case 3: // SEM
          addOperand("nullptr");
          break;
        case 4:
          Lex.GETnumberAttr(out n);
          break;
        case 5: // SEM
          isNum = true;
          break;
        case 6: // SEM
          addOperator("++prefix");
          break;
        case 7: // SEM
          addOperator("--prefix");
          break;
        case 8:
          Lex.GETidentAttr(out idStr);
          break;
        case 9: // SEM
          addOperand("ident"+ idStr);
          break;
        case 10:
          NT_Expr();
          break;
        case 11:
          NT_ActParList();
          break;
        case 12: // SEM
          addOperator("++postfix");
          break;
        case 13: // SEM
          addOperator("--postfix");
          break;
        case 14: // SEM
          addOperator("new");
          break;
        case 15:
          NT_Type();
          break;
        case 16:
          NT_Expr();
          break;
        case 17:
          NT_Expr();
          break;
      } // switch
    } // for
  } // NT_Fact

  private static void NT_ActParList() {
    for (;;) {
      switch (Syn.Interpret()) {
        case 0:
          return;
        case 1:
          NT_Expr();
          break;
        case 2:
          NT_Expr();
          break;
      } // switch
    } // for
  } // NT_ActParList


  public delegate void PragmaMethod();
  public static PragmaMethod[] pragmaMethods = {
      // none
    };


  public static void StartSem() {
  //-----------------------------------|----------------------------------------
    for (;;) {
      switch (Syn.Interpret()) {
        case 0:
          return;
        case 1:
          NT_MiniCpp();
          break;
      } // switch
    } // for
  } // StartSem

    
} // MiniCppSem

// End of MiniCppSem.cs
//=====================================|========================================
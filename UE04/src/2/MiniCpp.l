/*MiniCpp.l:                                            
  ------
  Description of the lexical structure for MiniCpp.
====================================================================*/

%{

  #include "MiniCpp.tab.h" /*generated by yacc/bison from MiniCpp.y
                          if option -d is used, defines NUMBER      */

%}

%x IN_COMMENT

%%

<INITIAL>{
"/*" BEGIN(IN_COMMENT);
}
<IN_COMMENT>{
"*/" BEGIN(INITIAL);
[^*\n]+ // eat comment in chunks
"*" // eat the lone star
\n yylineno++;
}

"//".*\n                { ; } /* ignore comments */
[ \t\r\n]+              { ; } /*ignore white space: blanks, tabs and new line */
[0-9]+                  { return NUMBER; }
const                   { return CONST; }
false                   { return FALSE; }
true                    { return TRUE; }
nullptr                 { return NULLPTR; }
void                    { return VOID; }
bool                    { return BOOL; }
int                     { return INT; }
if                      { return IF; }
else                    { return ELSE; }
while                   { return WHILE; }
break                   { return BREAK; }
cin                     { return CIN; }
cout                    { return COUT; }
endl                    { return ENDL; }
delete                  { return DELETE; }
return                  { return RETURN; }
new                     { return NEW; }
"&&"                    { return LOGICALAND; }
"||"                    { return LOGICALOR; }
"+="                    { return ADDASSIGN; }
"-="                    { return SUBTRACTASSIGN; }
"*="                    { return MULTIPLYASSIGN; }
"\\="                   { return DIVIDEASSIGN; }
"%="                    { return MODULOASSIGN; }
"++"                    { return OPINCREMENT; }
"--"                    { return OPDECREMENT; }
"<<"                    { return OPSHIFTLEFT; }
">>"                    { return OPSHIFTRIGHT; }
"=="                    { return OPEQUAL; }
"!="                    { return OPNOTEQUAL; }
"<"                     { return OPLESS; }
"<="                    { return OPLESSEQUAL; }
">"                     { return OPGREATER; }
">="                    { return OPGREATEREQUAL; }
[A-Za-z_][A-Za-z0-9\_]* { yylval.iIdent = strdup(yytext); return IDENT; }
\"([^\\\"]|\\.)*\"      { return STRING; } /* https://stackoverflow.com/questions/2039795/regular-expression-for-a-string-literal-in-flex-lex */
.                       { return yytext[0]; } /*return all other chars 
                                 as tokens: '+', '-', ...           */
%%

int yywrap() {
  return 1; /*on end of input: no further files to scan             */
} /*yywrap*/

/* End of MiniCpp.l
====================================================================*/
/*MiniCpp.l:                                            
  ------
  Description of the lexical structure for MiniCpp.
====================================================================*/

%{

  #include "MiniCpp.tab.h" /*generated by yacc/bison from MiniCpp.y
                          if option -d is used, defines NUMBER      */


%}

%x IN_COMMENT

%%

<INITIAL>{
"/*" BEGIN(IN_COMMENT);
}
<IN_COMMENT>{
"*/" BEGIN(INITIAL);
[^*\n]+ // eat comment in chunks
"*" // eat the lone star
\n yylineno++;
}

"//".*\n                { ; } /* ignore comments */
[ \t\r\n]+              { ; } /*ignore white space: blanks, tabs and new line */
[0-9]+                  { return NUMBER; }

CONST                   { return CONST; }
FALSE                   { return FALSE; }
TRUE                    { return TRUE; }
NULLPTR                 { return NULLPTR; }
VOID                    { return VOID; }
BOOL                    { return BOOL; }
INT                     { return INT; }
IF                      { return IF; }
ELSE                    { return ELSE; }
WHILE                   { return WHILE; }
BREAK                   { return BREAK; }
CIN                     { return CIN; }
COUT                    { return COUT; }
ENDL                    { return ENDL; }
DELETE                  { return DELETE; }
RETURN                  { return RETURN; }
NEW                     { return NEW; }

"&&"                    { return LOGICALAND; }
"||"                    { return LOGICALOR; }
"+="                    { return ADDASSIGN; }
"-="                    { return SUBTRACTASSIGN; }
"*="                    { return MULTIPLYASSIGN; }
"\="                    { return DIVIDEASSIGN; }
"%="                    { return MODULOASSIGN; }
"++"                    { return OPINCREMENT; }
"--"                    { return OPDECREMENT; }
"<<"                    { return OPSHIFTLEFT; }
">>"                    { return OPSHIFTRIGHT; }
"=="                    { return OPEQUAL; }
"!="                    { return OPNOTEQUAL; }
"<"                     { return OPLESS; }
"<="                    { return OPLESSEQUAL; }
">"                     { return OPGREATER; }
">="                    { return OPGREATEREQUAL; }


[A-Za-z_][A-Za-z0-9\_]* { return IDENT; }
\"([^\\\"]|\\.)*\"      { return STRING; } /* https://stackoverflow.com/questions/2039795/regular-expression-for-a-string-literal-in-flex-lex */
.                       { return yytext[0]; } /*return all other chars 
                                 as tokens: '+', '-', ...           */
%%

int yywrap() {
  return 1; /*on end of input: no further files to scan             */
} /*yywrap*/

/* End of MiniCpp.l
====================================================================*/